# RustFuzz 完整使用教程

## 目录
1. [环境准备](#环境准备)
2. [配置说明](#配置说明)
3. [完整工作流程](#完整工作流程)
4. [实战案例](#实战案例)
5. [高级技巧](#高级技巧)
6. [常见问题](#常见问题)

---

## 环境准备

### 1. 安装 Rust 工具链

```bash
# 安装 Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# 安装 nightly (cargo-fuzz 需要)
rustup install nightly
rustup default nightly

# 安装 cargo-fuzz
cargo install cargo-fuzz
```

### 2. 安装 Python 环境

```bash
# 推荐使用 Python 3.10+
python --version

# 安装依赖
pip install -r requirements.txt
```

### 3. 配置 LLM

#### 选项 A: 使用 OpenAI API

编辑 `config.toml`:

```toml
[llm]
openai_api_key = "sk-your-api-key-here"
openai_api_base = "https://api.openai.com/v1"
openai_model = "gpt-4"
use_ollama = false
```

#### 选项 B: 使用 Ollama 本地模型

```bash
# 安装 Ollama
curl https://ollama.ai/install.sh | sh

# 下载模型
ollama pull codellama:13b
# 或
ollama pull deepseek-coder:33b
```

编辑 `config.toml`:

```toml
[llm]
use_ollama = true
ollama_host = "http://localhost:11434"
ollama_model = "codellama:13b"
```

---

## 配置说明

### config.toml - 全局配置

```toml
[llm]
# LLM 配置
openai_api_key = ""
openai_model = "gpt-4"

[preprocessor]
# 是否提取测试用例作为示例
extract_test_cases = true
# 是否分析 unsafe 代码
analyze_unsafe_blocks = true

[generator]
# 每个 fuzz target 包含的函数数量
function_set_size = 3
# 最大生成轮次
max_rounds = 50
# 是否优先测试 unsafe 函数
prioritize_unsafe = true

[fuzzer]
# Fuzzing 引擎
engine = "libfuzzer"
# 单个 target 运行时间（秒）
timeout = 3600
# Sanitizer
sanitizers = ["address"]
```

### libraries.toml - 目标库配置

```toml
[your_crate]
language = "rust"
crate_path = "/path/to/your/crate"
source_paths = ["src"]
test_paths = ["tests"]
output_path = "output/your_crate"

# 可选配置
target_modules = []
exclude_paths = ["benches", "examples"]
features = []
api_hints = []
```

---

## 完整工作流程

### 第一步：初始化配置

```bash
# 创建默认配置（如果还没有）
python RustFuzz.py configure --init

# 编辑 config.toml 和 libraries.toml
# 填写 LLM API 密钥和目标 crate 路径
```

### 第二步：预处理阶段

分析目标 crate 的代码结构：

```bash
python RustFuzz.py preprocess -L your_crate
```

这一步会：
- 解析所有 Rust 源文件
- 提取函数、结构体、枚举、trait 定义
- 识别 unsafe 代码块
- 分析类型信息

输出文件：`output/your_crate/ast.json`

### 第三步：理解阶段（可选）

使用 LLM 理解 API 语义：

```bash
python RustFuzz.py comprehend -L your_crate
```

这一步会：
- 分析函数文档注释
- 理解 API 使用模式
- 识别函数之间的依赖关系

### 第四步：生成 Fuzz Target

```bash
# 生成 10 个 fuzz target
python RustFuzz.py generate -L your_crate --count 10

# 生成覆盖所有公开 API 的 fuzz target
python RustFuzz.py generate -L your_crate --task allcover

# 针对特定函数生成
python RustFuzz.py generate -L your_crate --task given --functions "parse,process,validate"
```

生成的文件位于：`output/your_crate/fuzz_targets/`

### 第五步：运行 Fuzzing

```bash
# 运行所有 fuzz target
python RustFuzz.py fuzz -L your_crate

# 运行特定 target
python RustFuzz.py fuzz -L your_crate --target fuzz_target_1

# 指定运行时间和并行数
python RustFuzz.py fuzz -L your_crate --timeout 7200 --jobs 4
```

### 第六步：分析结果

```bash
# 分析 crash
python RustFuzz.py analyze -L your_crate

# 查看统计信息
python RustFuzz.py stats -L your_crate

# 查看覆盖率
python RustFuzz.py stats -L your_crate --coverage
```

---

## 实战案例

### 案例 1: 测试 JSON 解析库

假设我们要测试一个 JSON 解析库：

#### 1. 配置

`libraries.toml`:
```toml
[my_json]
language = "rust"
crate_path = "/home/user/projects/my-json"
source_paths = ["src"]
output_path = "output/my_json"
features = ["serde"]
api_hints = [
    "parse() 函数解析 JSON 字符串",
    "需要处理无效的 UTF-8",
    "注意深层嵌套的 JSON"
]
```

#### 2. 运行

```bash
# 预处理
python RustFuzz.py preprocess -L my_json

# 生成 fuzz target（重点测试解析函数）
python RustFuzz.py generate -L my_json --task given --functions "parse,from_str,from_slice"

# 运行 fuzzing（6小时）
python RustFuzz.py fuzz -L my_json --timeout 21600
```

#### 3. 查看生成的 Fuzz Target

`output/my_json/fuzz_targets/fuzz_target_1.rs`:

```rust
#![no_main]
use libfuzzer_sys::fuzz_target;
use arbitrary::Arbitrary;

fuzz_target!(|data: &[u8]| {
    // 尝试将输入解析为 UTF-8
    if let Ok(s) = std::str::from_utf8(data) {
        // 调用解析函数
        let _ = my_json::parse(s);
    }
    
    // 也测试非 UTF-8 输入
    let _ = my_json::from_slice(data);
});
```

### 案例 2: 测试图像处理库

#### 1. 配置

```toml
[image_proc]
language = "rust"
crate_path = "/home/user/projects/image-proc"
source_paths = ["src"]
output_path = "output/image_proc"
features = ["png", "jpeg"]
api_hints = [
    "decode() 解码图像数据",
    "需要验证图像尺寸",
    "注意整数溢出"
]
```

#### 2. 运行

```bash
# 完整流程
python RustFuzz.py preprocess -L image_proc
python RustFuzz.py generate -L image_proc --count 15
python RustFuzz.py fuzz -L image_proc --timeout 3600

# 分析结果
python RustFuzz.py analyze -L image_proc
```

### 案例 3: 测试 Unsafe 代码

对于包含大量 unsafe 的项目：

#### 1. 配置

```toml
[unsafe_lib]
language = "rust"
crate_path = "/home/user/projects/unsafe-lib"
source_paths = ["src"]
output_path = "output/unsafe_lib"

# 在 config.toml 中
[preprocessor]
analyze_unsafe_blocks = true

[generator]
prioritize_unsafe = true
```

#### 2. 运行

```bash
python RustFuzz.py preprocess -L unsafe_lib
# 工具会自动识别并优先测试包含 unsafe 的函数
python RustFuzz.py generate -L unsafe_lib --task allcover
python RustFuzz.py fuzz -L unsafe_lib
```

---

## 高级技巧

### 1. 提供种子输入

为提高 fuzzing 效率，可以提供初始种子：

```bash
# 在 fuzz 项目目录中创建 corpus
mkdir -p output/your_crate/fuzz_project/fuzz/corpus/fuzz_target_1
# 将种子文件放入该目录
cp seed_files/* output/your_crate/fuzz_project/fuzz/corpus/fuzz_target_1/
```

### 2. 使用字典

创建字典文件提示 fuzzer 有用的输入片段：

`dictionary.txt`:
```
"{"
"}"
"["
"]"
":"
","
"null"
"true"
"false"
"\x00"
```

在 `config.toml` 中指定：
```toml
[fuzzer]
dictionary_path = "dictionary.txt"
```

### 3. 自定义 Fuzz Target

手动编辑生成的 fuzz target，添加特定逻辑：

```rust
#![no_main]
use libfuzzer_sys::fuzz_target;

fuzz_target!(|data: &[u8]| {
    // 自定义输入处理
    if data.len() < 4 {
        return;
    }
    
    // 分割输入用于不同参数
    let (param1, param2) = data.split_at(data.len() / 2);
    
    // 调用目标函数
    let _ = my_lib::complex_function(param1, param2);
});
```

### 4. 使用 Arbitrary 生成结构化输入

```rust
#![no_main]
use libfuzzer_sys::fuzz_target;
use arbitrary::Arbitrary;

#[derive(Arbitrary, Debug)]
struct Input {
    field1: u32,
    field2: String,
    field3: Vec<u8>,
}

fuzz_target!(|input: Input| {
    let _ = my_lib::process(
        input.field1,
        &input.field2,
        &input.field3
    );
});
```

### 5. 并行 Fuzzing

在多台机器或多个 CPU 核心上并行：

```bash
# 机器 1
python RustFuzz.py fuzz -L your_crate --jobs 8

# 机器 2（使用相同的 corpus）
# 同步 corpus 目录
rsync -av machine1:output/your_crate/fuzz_project/fuzz/corpus/ ./corpus/
python RustFuzz.py fuzz -L your_crate --jobs 8
```

### 6. 持续集成

在 CI/CD 中集成 fuzzing：

`.github/workflows/fuzz.yml`:
```yaml
name: Fuzzing
on:
  schedule:
    - cron: '0 0 * * *'  # 每天运行

jobs:
  fuzz:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: nightly
      - name: Install cargo-fuzz
        run: cargo install cargo-fuzz
      - name: Install Python deps
        run: pip install -r requirements.txt
      - name: Run fuzzing
        run: |
          python RustFuzz.py preprocess -L my_crate
          python RustFuzz.py generate -L my_crate --count 5
          python RustFuzz.py fuzz -L my_crate --timeout 3600
      - name: Upload crashes
        if: failure()
        uses: actions/upload-artifact@v2
        with:
          name: crashes
          path: output/*/crash_report.json
```

---

## 常见问题

### Q1: 生成的 fuzz target 编译失败？

**A**: 检查以下几点：

1. 确保 `Cargo.toml` 中包含必要的依赖：
```toml
[dependencies]
libfuzzer-sys = "0.4"
arbitrary = "1.0"
```

2. 检查导入路径是否正确
3. 手动修正生成的代码中的类型错误

### Q2: Fuzzing 运行很慢，没有发现任何问题？

**A**: 尝试：

1. 提供更好的种子输入
2. 增加运行时间
3. 调整 LLM prompt 生成更有针对性的测试
4. 手动编辑 fuzz target 提高效率

### Q3: 如何调试 crash？

**A**: 

```bash
# 使用 crash 输入重现
cargo fuzz run fuzz_target_1 output/crash-xxx

# 使用 debugger
rust-lldb target/x86_64-unknown-linux-gnu/release/fuzz_target_1 output/crash-xxx
```

### Q4: 如何测试私有函数？

**A**: 

1. 在 `libraries.toml` 中设置：
```toml
include_private = true
```

2. 在被测试的 crate 中添加：
```rust
#[cfg(fuzzing)]
pub use private_module::private_function;
```

### Q5: LLM 生成的代码质量不高？

**A**: 

1. 使用更强大的模型（如 GPT-4）
2. 在 `libraries.toml` 中提供更详细的 `api_hints`
3. 手动编辑和改进生成的代码
4. 调整 prompt template

### Q6: 如何提高覆盖率？

**A**: 

1. 生成更多样化的 fuzz target
2. 使用结构化输入（Arbitrary）
3. 提供有针对性的种子
4. 结合代码覆盖率分析调整策略

---

## 最佳实践

### 1. 循序渐进

- 从简单的函数开始
- 逐步增加复杂度
- 定期查看和分析结果

### 2. 专注高风险区域

- 优先测试 unsafe 代码
- 重点关注解析和反序列化
- 测试边界条件处理

### 3. 结合其他测试

- 单元测试覆盖正常情况
- Fuzzing 发现边界情况
- 集成测试验证整体行为

### 4. 持续优化

- 定期更新 fuzz target
- 根据发现调整策略
- 保持 corpus 的多样性

---

## 总结

RustFuzz 提供了一个端到端的 Rust 漏洞挖掘解决方案：

1. **自动化**: 从代码分析到 fuzz target 生成全自动
2. **智能化**: 利用 LLM 理解代码语义
3. **针对性**: 专门优化 Rust 特性
4. **灵活性**: 支持手动调整和优化

通过本教程，你应该能够：
- ✅ 配置 RustFuzz 环境
- ✅ 分析和生成 fuzz target
- ✅ 运行 fuzzing 并分析结果
- ✅ 应用高级技巧提高效率

祝 fuzzing 愉快！🦀🔍
